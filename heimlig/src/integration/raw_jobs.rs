use crate::common::jobs::{Request, Response};
use crate::integration::raw_errors::JobErrorRaw;
use core::slice;

/// Function to trigger the generation of `RequestRaw` and `ResponseRaw` definition
#[no_mangle]
pub extern "C" fn trigger_cbindgen_request_raw_response_raw(_request: RequestRaw) -> ResponseRaw {
    unreachable!()
}

type ClientIdRaw = u32;
type RequestIdRaw = u32;
type KeyIdRaw = u32;

// TODO: replace with core::mem::variant_count::<RequestRaw>(); once it is stable
// https://github.com/rust-lang/rust/issues/73662
const REQUEST_RAW_VARIANTS: u8 = 9;

// TODO: Raw types could be generated by a macro from the non-raw type
/// Raw request as it is written by clients to shared memory. This type is supposed to be synced
/// with non-Rust (e.g. C++) clients via cbindgen.
///
/// # Safety
///
/// To ensure safe parsing of incoming requests, this struct must be "cast-safe", i.e. all members
/// must be valid for all possible values found in memory. Note that this does not mean that all
/// pointers have to point to valid addresses as they can be checked after casting. However, a
/// nested enum member is not allowed as casting an enum from a value outside the enum range causes
/// UB in Rust even without accessing the resulting enum.
#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub enum RequestRaw {
    GetRandom {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        output_data: *mut u8,
        output_size: u32,
    },
    GenerateSymmetricKey {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        key_id: KeyIdRaw,
        overwrite: bool,
    },
    GenerateKeyPair {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        key_id: KeyIdRaw,
        overwrite: bool,
    },
    ImportSymmetricKey {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        key_id: KeyIdRaw,
        data_data: *const u8,
        data_size: u32,
        overwrite: bool,
    },
    ImportKeyPair {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        key_id: KeyIdRaw,
        public_key_data: *const u8,
        public_key_size: u32,
        private_key_data: *const u8,
        private_key_size: u32,
        overwrite: bool,
    },
    ExportSymmetricKey {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        key_id: KeyIdRaw,
        data_data: *mut u8,
        data_size: u32,
    },
    ExportPublicKey {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        key_id: KeyIdRaw,
        public_key_data: *mut u8,
        public_key_size: u32,
    },
    ExportPrivateKey {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        key_id: KeyIdRaw,
        private_key_data: *mut u8,
        private_key_size: u32,
    },
    EncryptChaChaPoly {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        key_id: KeyIdRaw,
        nonce_data: *const u8,
        nonce_size: u32,
        plaintext_data: *mut u8,
        plaintext_size: u32,
        aad_data: *const u8,
        aad_size: u32,
        tag_data: *mut u8,
        tag_size: u32,
    },
    EncryptChaChaPolyExternalKey {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        key_data: *const u8,
        key_size: u32,
        nonce_data: *const u8,
        nonce_size: u32,
        plaintext_data: *mut u8,
        plaintext_size: u32,
        aad_data: *const u8,
        aad_size: u32,
        tag_data: *mut u8,
        tag_size: u32,
    },
    DecryptChaChaPoly {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        key_id: KeyIdRaw,
        nonce_data: *const u8,
        nonce_size: u32,
        ciphertext_data: *mut u8,
        ciphertext_size: u32,
        aad_data: *const u8,
        aad_size: u32,
        tag_data: *const u8,
        tag_size: u32,
    },
    DecryptChaChaPolyExternalKey {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        key_data: *const u8,
        key_size: u32,
        nonce_data: *const u8,
        nonce_size: u32,
        ciphertext_data: *mut u8,
        ciphertext_size: u32,
        aad_data: *const u8,
        aad_size: u32,
        tag_data: *const u8,
        tag_size: u32,
    },
}

/// Raw response as it is written by clients to shared memory. This type is supposed to be synced
/// with non-Rust (e.g. C++) clients via cbindgen.
#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub enum ResponseRaw {
    Error {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        error: JobErrorRaw,
    },
    GetRandom {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        data_data: *mut u8,
        data_size: u32,
    },
    GenerateSymmetricKey {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
    },
    GenerateKeyPair {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
    },
    ImportSymmetricKey {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
    },
    ImportKeyPair {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
    },
    ExportSymmetricKey {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        key_data: *const u8,
        key_size: u32,
    },
    ExportPublicKey {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        public_key_data: *const u8,
        public_key_size: u32,
    },
    ExportPrivateKey {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        private_key_data: *const u8,
        private_key_size: u32,
    },
    EncryptChaChaPoly {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        ciphertext_data: *const u8,
        ciphertext_size: u32,
        tag_data: *mut u8,
        tag_size: u32,
    },
    DecryptChaChaPoly {
        client_id: ClientIdRaw,
        request_id: RequestIdRaw,
        plaintext_data: *const u8,
        plaintext_size: u32,
    },
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum ValidationError {
    InvalidPointer,
    InvalidTagValue,
}

impl RequestRaw {
    /// Create a `RequestRaw` from a raw pointer.
    ///
    /// # Arguments
    ///
    /// * `request`: The pointer to the first byte of the `RequestRaw`
    /// * `validator`: Function that will be called to check the `request` pointer.
    /// A valid pointer should fall into a specific address range and be properly aligned.
    /// These checks (other than null) must be provided by the integrator.
    ///
    /// returns: Result<RequestRaw, ()>
    ///
    /// # Safety
    ///
    /// The provided pointer must be valid (non-null, aligned, point to valid memory) and point to a
    /// valid `RequestRaw` instance.  
    ///
    pub unsafe fn from_raw(request_addr: *const u8) -> Result<Self, ValidationError> {
        // Unsafe: Pointer and size must be checked by integrator
        let tag: u8 = unsafe { *request_addr };

        // Validate tag value. Invalid tag values cause UB when transmuted into an enum.
        if tag >= REQUEST_RAW_VARIANTS {
            return Err(ValidationError::InvalidTagValue);
        }

        // Safety: All members of RequestRaw are valid for all possible values found in memory
        Ok(*request_addr.cast::<RequestRaw>())
    }

    pub fn verify<'data>(
        self,
        validator: &impl Fn(*const u8, u32) -> bool,
    ) -> Result<Request<'data>, ValidationError> {
        let request = match self {
            RequestRaw::GetRandom {
                client_id,
                request_id,
                output_data,
                output_size,
            } => {
                check_pointer_and_size(output_data, output_size, &validator)?;
                Request::GetRandom {
                    client_id: client_id.into(),
                    request_id: request_id.into(),
                    output: check_mut_pointer_and_size(output_data, output_size, &validator)?,
                }
            }
            RequestRaw::GenerateSymmetricKey {
                client_id,
                request_id,
                key_id,
                overwrite,
            } => Request::GenerateSymmetricKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                overwrite,
            },
            RequestRaw::GenerateKeyPair {
                client_id,
                request_id,
                key_id,
                overwrite,
            } => Request::GenerateKeyPair {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                overwrite,
            },
            RequestRaw::ImportSymmetricKey {
                client_id,
                request_id,
                key_id,
                data_data,
                data_size,
                overwrite,
            } => Request::ImportSymmetricKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                data: check_pointer_and_size(data_data, data_size, &validator)?,
                overwrite,
            },
            RequestRaw::ImportKeyPair {
                client_id,
                request_id,
                key_id,
                public_key_data,
                public_key_size,
                private_key_data,
                private_key_size,
                overwrite,
            } => Request::ImportKeyPair {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                public_key: check_pointer_and_size(public_key_data, public_key_size, &validator)?,
                private_key: check_pointer_and_size(
                    private_key_data,
                    private_key_size,
                    &validator,
                )?,
                overwrite,
            },
            RequestRaw::ExportSymmetricKey {
                client_id,
                request_id,
                key_id,
                data_data,
                data_size,
            } => Request::ExportSymmetricKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                data: check_mut_pointer_and_size(data_data, data_size, &validator)?,
            },
            RequestRaw::ExportPublicKey {
                client_id,
                request_id,
                key_id,
                public_key_data,
                public_key_size,
            } => Request::ExportPublicKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                public_key: check_mut_pointer_and_size(
                    public_key_data,
                    public_key_size,
                    &validator,
                )?,
            },
            RequestRaw::ExportPrivateKey {
                client_id,
                request_id,
                key_id,
                private_key_data,
                private_key_size,
            } => Request::ExportPrivateKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                private_key: check_mut_pointer_and_size(
                    private_key_data,
                    private_key_size,
                    &validator,
                )?,
            },
            RequestRaw::EncryptChaChaPoly {
                client_id,
                request_id,
                key_id,
                nonce_data,
                nonce_size,
                plaintext_data,
                plaintext_size,
                aad_data,
                aad_size,
                tag_data,
                tag_size,
            } => Request::EncryptChaChaPoly {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                nonce: check_pointer_and_size(nonce_data, nonce_size, &validator)?,
                plaintext: check_mut_pointer_and_size(plaintext_data, plaintext_size, &validator)?,
                aad: check_pointer_and_size(aad_data, aad_size, &validator)?,
                tag: check_mut_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestRaw::EncryptChaChaPolyExternalKey {
                client_id,
                request_id,
                key_data,
                key_size,
                nonce_data,
                nonce_size,
                plaintext_data,
                plaintext_size,
                aad_data,
                aad_size,
                tag_data,
                tag_size,
            } => Request::EncryptChaChaPolyExternalKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key: check_pointer_and_size(key_data, key_size, &validator)?,
                nonce: check_pointer_and_size(nonce_data, nonce_size, &validator)?,
                plaintext: check_mut_pointer_and_size(plaintext_data, plaintext_size, &validator)?,
                aad: check_pointer_and_size(aad_data, aad_size, &validator)?,
                tag: check_mut_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestRaw::DecryptChaChaPoly {
                client_id,
                request_id,
                key_id,
                nonce_data,
                nonce_size,
                ciphertext_data,
                ciphertext_size,
                aad_data,
                aad_size,
                tag_data,
                tag_size,
            } => {
                check_pointer_and_size(nonce_data, nonce_size, &validator)?;
                check_pointer_and_size(ciphertext_data, ciphertext_size, &validator)?;
                check_pointer_and_size(aad_data, aad_size, &validator)?;
                check_pointer_and_size(tag_data, tag_size, &validator)?;
                Request::DecryptChaChaPoly {
                    client_id: client_id.into(),
                    request_id: request_id.into(),
                    key_id: key_id.into(),
                    nonce: &[],
                    ciphertext: &mut [],
                    aad: &[],
                    tag: &[],
                }
            }
            RequestRaw::DecryptChaChaPolyExternalKey {
                client_id,
                request_id,
                key_data,
                key_size,
                nonce_data,
                nonce_size,
                ciphertext_data,
                ciphertext_size,
                aad_data,
                aad_size,
                tag_data,
                tag_size,
            } => {
                check_pointer_and_size(key_data, key_size, &validator)?;
                check_pointer_and_size(nonce_data, nonce_size, &validator)?;
                check_pointer_and_size(ciphertext_data, ciphertext_size, &validator)?;
                check_pointer_and_size(aad_data, aad_size, &validator)?;
                check_pointer_and_size(tag_data, tag_size, &validator)?;
                Request::DecryptChaChaPolyExternalKey {
                    client_id: client_id.into(),
                    request_id: request_id.into(),
                    key: check_pointer_and_size(key_data, key_size, &validator)?,
                    nonce: &[],
                    ciphertext: &mut [],
                    aad: &[],
                    tag: &[],
                }
            }
        };
        Ok(request)
    }
}

// Outgoing direction. No validation needed.
impl From<Request<'_>> for RequestRaw {
    fn from(request: Request) -> Self {
        match request {
            Request::GetRandom {
                client_id,
                request_id,
                output,
            } => RequestRaw::GetRandom {
                client_id: client_id.into(),
                request_id: request_id.into(),
                output_data: output.as_mut_ptr(),
                output_size: output.len() as u32,
            },
            Request::GenerateSymmetricKey {
                client_id,
                request_id,
                key_id,
                overwrite,
            } => RequestRaw::GenerateSymmetricKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                overwrite,
            },
            Request::GenerateKeyPair {
                client_id,
                request_id,
                key_id,
                overwrite,
            } => RequestRaw::GenerateKeyPair {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                overwrite,
            },
            Request::ImportSymmetricKey {
                client_id,
                request_id,
                key_id,
                data,
                overwrite,
            } => RequestRaw::ImportSymmetricKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                data_data: data.as_ptr(),
                data_size: data.len() as u32,
                overwrite,
            },
            Request::ImportKeyPair {
                client_id,
                request_id,
                key_id,
                public_key,
                private_key,
                overwrite,
            } => RequestRaw::ImportKeyPair {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                public_key_data: public_key.as_ptr(),
                public_key_size: public_key.len() as u32,
                private_key_data: private_key.as_ptr(),
                private_key_size: private_key.len() as u32,
                overwrite,
            },
            Request::ExportSymmetricKey {
                client_id,
                request_id,
                key_id,
                data,
            } => RequestRaw::ExportSymmetricKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                data_data: data.as_mut_ptr(),
                data_size: data.len() as u32,
            },
            Request::ExportPublicKey {
                client_id,
                request_id,
                key_id,
                public_key,
            } => RequestRaw::ExportPublicKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                public_key_data: public_key.as_mut_ptr(),
                public_key_size: public_key.len() as u32,
            },
            Request::ExportPrivateKey {
                client_id,
                request_id,
                key_id,
                private_key,
            } => RequestRaw::ExportPrivateKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                private_key_data: private_key.as_mut_ptr(),
                private_key_size: private_key.len() as u32,
            },
            Request::EncryptChaChaPoly {
                client_id,
                request_id,
                key_id,
                nonce,
                plaintext,
                aad,
                tag,
            } => RequestRaw::EncryptChaChaPoly {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                nonce_data: nonce.as_ptr(),
                nonce_size: nonce.len() as u32,
                plaintext_data: plaintext.as_mut_ptr(),
                plaintext_size: plaintext.len() as u32,
                aad_data: aad.as_ptr(),
                aad_size: aad.len() as u32,
                tag_data: tag.as_mut_ptr(),
                tag_size: tag.len() as u32,
            },
            Request::EncryptChaChaPolyExternalKey {
                client_id,
                request_id,
                key,
                nonce,
                plaintext,
                aad,
                tag,
            } => RequestRaw::EncryptChaChaPolyExternalKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_data: key.as_ptr(),
                key_size: key.len() as u32,
                nonce_data: nonce.as_ptr(),
                nonce_size: nonce.len() as u32,
                plaintext_data: plaintext.as_mut_ptr(),
                plaintext_size: plaintext.len() as u32,
                aad_data: aad.as_ptr(),
                aad_size: aad.len() as u32,
                tag_data: tag.as_mut_ptr(),
                tag_size: tag.len() as u32,
            },
            Request::DecryptChaChaPoly {
                client_id,
                request_id,
                key_id,
                nonce,
                ciphertext,
                aad,
                tag,
            } => RequestRaw::DecryptChaChaPoly {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_id: key_id.into(),
                nonce_data: nonce.as_ptr(),
                nonce_size: nonce.len() as u32,
                ciphertext_data: ciphertext.as_mut_ptr(),
                ciphertext_size: ciphertext.len() as u32,
                aad_data: aad.as_ptr(),
                aad_size: aad.len() as u32,
                tag_data: tag.as_ptr(),
                tag_size: tag.len() as u32,
            },
            Request::DecryptChaChaPolyExternalKey {
                client_id,
                request_id,
                key,
                nonce,
                ciphertext,
                aad,
                tag,
            } => RequestRaw::DecryptChaChaPolyExternalKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_data: key.as_ptr(),
                key_size: key.len() as u32,
                nonce_data: nonce.as_ptr(),
                nonce_size: nonce.len() as u32,
                ciphertext_data: ciphertext.as_mut_ptr(),
                ciphertext_size: ciphertext.len() as u32,
                aad_data: aad.as_ptr(),
                aad_size: aad.len() as u32,
                tag_data: tag.as_ptr(),
                tag_size: tag.len() as u32,
            },
        }
    }
}

// Outgoing direction. No validation needed.
impl From<Response<'_>> for ResponseRaw {
    fn from(value: Response<'_>) -> Self {
        match value {
            Response::Error {
                client_id,
                request_id,
                error,
            } => ResponseRaw::Error {
                client_id: client_id.into(),
                request_id: request_id.into(),
                error: error.into(),
            },
            Response::GetRandom {
                client_id,
                request_id,
                data,
            } => ResponseRaw::GetRandom {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data_data: data.as_mut_ptr(),
                data_size: data.len() as u32,
            },
            Response::GenerateSymmetricKey {
                client_id,
                request_id,
            } => ResponseRaw::GenerateSymmetricKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
            },
            Response::GenerateKeyPair {
                client_id,
                request_id,
            } => ResponseRaw::GenerateKeyPair {
                client_id: client_id.into(),
                request_id: request_id.into(),
            },
            Response::ImportSymmetricKey {
                client_id,
                request_id,
            } => ResponseRaw::ImportSymmetricKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
            },
            Response::ImportKeyPair {
                client_id,
                request_id,
            } => ResponseRaw::ImportKeyPair {
                client_id: client_id.into(),
                request_id: request_id.into(),
            },
            Response::ExportSymmetricKey {
                client_id,
                request_id,
                key,
            } => ResponseRaw::ExportSymmetricKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                key_data: key.as_ptr(),
                key_size: key.len() as u32,
            },
            Response::ExportPublicKey {
                client_id,
                request_id,
                public_key,
            } => ResponseRaw::ExportPublicKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                public_key_data: public_key.as_ptr(),
                public_key_size: public_key.len() as u32,
            },
            Response::ExportPrivateKey {
                client_id,
                request_id,
                private_key,
            } => ResponseRaw::ExportPrivateKey {
                client_id: client_id.into(),
                request_id: request_id.into(),
                private_key_data: private_key.as_ptr(),
                private_key_size: private_key.len() as u32,
            },
            Response::EncryptChaChaPoly {
                client_id,
                request_id,
                ciphertext,
                tag,
            } => ResponseRaw::EncryptChaChaPoly {
                client_id: client_id.into(),
                request_id: request_id.into(),
                ciphertext_data: ciphertext.as_mut_ptr(),
                ciphertext_size: ciphertext.len() as u32,
                tag_data: tag.as_mut_ptr(),
                tag_size: tag.len() as u32,
            },
            Response::DecryptChaChaPoly {
                client_id,
                request_id,
                plaintext,
            } => ResponseRaw::DecryptChaChaPoly {
                client_id: client_id.into(),
                request_id: request_id.into(),
                plaintext_data: plaintext.as_mut_ptr(),
                plaintext_size: plaintext.len() as u32,
            },
        }
    }
}

/// Check an untrusted pointer and size pair using a provided validator function.
fn check_pointer_and_size<'a>(
    data: *const u8,
    size: u32,
    validator: &impl Fn(*const u8, u32) -> bool,
) -> Result<&'a [u8], ValidationError> {
    if data.is_null() {
        return Err(ValidationError::InvalidPointer);
    }
    if !validator(data, size) {
        return Err(ValidationError::InvalidPointer);
    }
    Ok(unsafe { slice::from_raw_parts(data, size as usize) })
}

/// Check an untrusted pointer and size pair using a provided validator function.
fn check_mut_pointer_and_size<'a>(
    data: *mut u8,
    size: u32,
    validator: &impl Fn(*const u8, u32) -> bool,
) -> Result<&'a mut [u8], ValidationError> {
    if data.is_null() {
        return Err(ValidationError::InvalidPointer);
    }
    if !validator(data, size) {
        return Err(ValidationError::InvalidPointer);
    }
    Ok(unsafe { slice::from_raw_parts_mut(data, size as usize) })
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::common::jobs::Request::GetRandom;
    use crate::common::jobs::{ClientId, RequestId};
    use core::{mem, ptr};

    #[test]
    fn test_serialize_deserialize() {
        let client_id = ClientId(5);
        let request_id = RequestId(7);
        let mut shared_memory = [0u8; 16];
        let request = GetRandom {
            client_id,
            request_id,
            output: &mut shared_memory,
        };
        let request_raw: RequestRaw = request.into();
        let request_raw_ptr = &request_raw as *const RequestRaw as *const u8;
        let reconstructed_request_raw = unsafe { RequestRaw::from_raw(request_raw_ptr) }
            .expect("failed to create raw request from pointer.");
        let always_valid = |_data: *const u8, _size: u32| true;
        let reconstructed_request = reconstructed_request_raw
            .verify(&always_valid)
            .expect("failed to verify raw request");
        match reconstructed_request {
            GetRandom {
                client_id: reconstructed_client_id,
                request_id: reconstructed_request_id,
                output: reconstructed_output,
            } => {
                assert_eq!(reconstructed_client_id, client_id);
                assert_eq!(reconstructed_request_id, request_id);
                assert_eq!(reconstructed_output.as_ptr(), shared_memory.as_ptr());
                assert_eq!(reconstructed_output.len(), shared_memory.len());
            }
            _ => {
                panic!("Unexpected reconstructed request type")
            }
        }
    }

    #[test]
    fn test_invalid_buffer_size() {
        let client_id = ClientId(5);
        let request_id = RequestId(7);
        const OUTPUT_SIZE: usize = 16;
        let mut shared_memory = [0u8; mem::size_of::<RequestRaw>() + OUTPUT_SIZE];
        let request_raw_start = shared_memory.as_mut_ptr();
        let output_start = unsafe { shared_memory.as_mut_ptr().add(mem::size_of::<RequestRaw>()) };
        let request = GetRandom {
            client_id,
            request_id,
            output: unsafe { slice::from_raw_parts_mut(output_start, OUTPUT_SIZE) },
        };
        let request_raw: RequestRaw = request.into();
        unsafe {
            ptr::copy(&request_raw, request_raw_start as *mut RequestRaw, 1);
        }

        let is_in_shared_memory_1st_half = |data: *const u8, size: u32| {
            let start_data = data;
            let end_data = unsafe { start_data.add(size as usize) };
            let start_shared_memory = shared_memory.as_ptr();
            let end_shared_memory_1st_half =
                unsafe { start_shared_memory.add(shared_memory.len() / 2) };
            start_shared_memory <= start_data && end_data <= end_shared_memory_1st_half
        };
        let request_raw = unsafe { RequestRaw::from_raw(request_raw_start) }
            .expect("failed to create raw request from pointer.");
        match request_raw.verify(&is_in_shared_memory_1st_half) {
            Ok(_) => {
                panic!("Expected request raw reconstruction to fail")
            }
            Err(e) => match e {
                ValidationError::InvalidPointer => {}
                _ => {
                    panic!("Unexpected validation error variant")
                }
            },
        }
    }

    #[test]
    fn test_invalid_enum_tag() {
        let client_id = ClientId(5);
        let request_id = RequestId(7);
        const OUTPUT_SIZE: usize = 16;
        let mut shared_memory = [0u8; mem::size_of::<RequestRaw>() + OUTPUT_SIZE];
        let request_raw_start = shared_memory.as_mut_ptr();
        let output_start = unsafe { shared_memory.as_mut_ptr().add(mem::size_of::<RequestRaw>()) };
        let request = GetRandom {
            client_id,
            request_id,
            output: unsafe { slice::from_raw_parts_mut(output_start, OUTPUT_SIZE) },
        };
        let request_raw: RequestRaw = request.into();
        unsafe {
            ptr::copy(&request_raw, request_raw_start as *mut RequestRaw, 1);
            let tag: *mut u8 = request_raw_start;
            const INVALID_TAG: u8 = 0xFF;
            *tag = INVALID_TAG;
        }
        match unsafe { RequestRaw::from_raw(request_raw_start) } {
            Ok(_) => {
                panic!("Expected request raw reconstruction to fail")
            }
            Err(e) => match e {
                ValidationError::InvalidTagValue => {}
                _ => {
                    panic!("Unexpected validation error variant")
                }
            },
        }
    }
}
