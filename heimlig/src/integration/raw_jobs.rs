use crate::common::jobs::{HashAlgorithm, Request, Response};
use crate::hsm::keystore::{Curve, KeyId};
use crate::integration::raw_errors::JobErrorRaw;
use core::mem::offset_of;
use core::slice;
use strum::EnumCount;

type ClientIdRaw = u32;
type RequestIdRaw = u32;
type KeyIdRaw = u32;
type CurveRaw = u32;
type HashAlgorithmRaw = u32;
type BoolRaw = u32; // 0 == false, 1 == true

pub const NIST_P256: CurveRaw = 0;
pub const NIST_P384: CurveRaw = 1;

pub const SHA2_256: HashAlgorithmRaw = 0;
pub const SHA2_384: HashAlgorithmRaw = 1;
pub const SHA2_512: HashAlgorithmRaw = 2;
pub const SHA3_256: HashAlgorithmRaw = 3;
pub const SHA3_384: HashAlgorithmRaw = 4;
pub const SHA3_512: HashAlgorithmRaw = 5;

/// A pair of a raw request and a raw response. This is a convenience type for integrators to
/// allocate all necessary memory for a request and its response in one go.
#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct RequestResponseRawPair {
    pub request: RequestRaw,
    pub response: ResponseRaw,
}

// TODO: Raw types could be generated by a macro from the non-raw type
/// Raw request as it is written by clients to shared memory. This type is supposed to be synced
/// with non-Rust (e.g. C++) clients via cbindgen.
///
/// # Safety
///
/// To ensure safe parsing of incoming requests, this struct must be "cast-safe", i.e. all members
/// must be valid for all possible values found in memory. Note that this does not mean that all
/// pointers have to point to valid addresses as they can be checked after casting. However, a
/// nested enum member is not allowed as casting an enum from a value outside the enum range causes
/// UB in Rust even without accessing the resulting enum.
#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct RequestRaw {
    client_id: ClientIdRaw,
    request_id: RequestIdRaw,
    data: RequestDataRaw,
}

/// Raw request as it is written by clients to shared memory. This type is supposed to be synced
/// with non-Rust (e.g. C++) clients via cbindgen.
#[repr(C, u8)]
#[derive(Clone, Copy, Debug, EnumCount)]
pub enum RequestDataRaw {
    GetRandom {
        output_data: *mut u8,
        output_size: u32,
    },
    GenerateSymmetricKey {
        key_id: KeyIdRaw,
        overwrite: BoolRaw,
    },
    GenerateKeyPair {
        key_id: KeyIdRaw,
        overwrite: BoolRaw,
    },
    ImportSymmetricKey {
        key_id: KeyIdRaw,
        data_data: *const u8,
        data_size: u32,
        overwrite: BoolRaw,
    },
    ImportKeyPair {
        key_id: KeyIdRaw,
        public_key_data: *const u8,
        public_key_size: u32,
        private_key_data: *const u8,
        private_key_size: u32,
        overwrite: BoolRaw,
    },
    ExportSymmetricKey {
        key_id: KeyIdRaw,
        data_data: *mut u8,
        data_size: u32,
    },
    ExportPublicKey {
        key_id: KeyIdRaw,
        public_key_data: *mut u8,
        public_key_size: u32,
    },
    ExportPrivateKey {
        key_id: KeyIdRaw,
        private_key_data: *mut u8,
        private_key_size: u32,
    },
    IsKeyAvailable {
        key_id: KeyIdRaw,
    },
    EncryptChaChaPoly {
        key_id: KeyIdRaw,
        nonce_data: *const u8,
        nonce_size: u32,
        buffer_data: *mut u8,
        buffer_size: u32,
        aad_data: *const u8,
        aad_size: u32,
        tag_data: *mut u8,
        tag_size: u32,
    },
    EncryptChaChaPolyExternalKey {
        key_data: *const u8,
        key_size: u32,
        nonce_data: *const u8,
        nonce_size: u32,
        buffer_data: *mut u8,
        buffer_size: u32,
        aad_data: *const u8,
        aad_size: u32,
        tag_data: *mut u8,
        tag_size: u32,
    },
    DecryptChaChaPoly {
        key_id: KeyIdRaw,
        nonce_data: *const u8,
        nonce_size: u32,
        buffer_data: *mut u8,
        buffer_size: u32,
        aad_data: *const u8,
        aad_size: u32,
        tag_data: *const u8,
        tag_size: u32,
    },
    DecryptChaChaPolyExternalKey {
        key_data: *const u8,
        key_size: u32,
        nonce_data: *const u8,
        nonce_size: u32,
        buffer_data: *mut u8,
        buffer_size: u32,
        aad_data: *const u8,
        aad_size: u32,
        tag_data: *const u8,
        tag_size: u32,
    },
    EncryptAesGcm {
        key_id: KeyIdRaw,
        iv_data: *const u8,
        iv_size: u32,
        buffer_data: *mut u8,
        buffer_size: u32,
        aad_data: *const u8,
        aad_size: u32,
        tag_data: *mut u8,
        tag_size: u32,
    },
    EncryptAesGcmExternalKey {
        key_data: *const u8,
        key_size: u32,
        iv_data: *const u8,
        iv_size: u32,
        buffer_data: *mut u8,
        buffer_size: u32,
        aad_data: *const u8,
        aad_size: u32,
        tag_data: *mut u8,
        tag_size: u32,
    },
    DecryptAesGcm {
        key_id: KeyIdRaw,
        iv_data: *const u8,
        iv_size: u32,
        buffer_data: *mut u8,
        buffer_size: u32,
        aad_data: *const u8,
        aad_size: u32,
        tag_data: *const u8,
        tag_size: u32,
    },
    DecryptAesGcmExternalKey {
        key_data: *const u8,
        key_size: u32,
        iv_data: *const u8,
        iv_size: u32,
        buffer_data: *mut u8,
        buffer_size: u32,
        aad_data: *const u8,
        aad_size: u32,
        tag_data: *const u8,
        tag_size: u32,
    },
    EncryptAesCbc {
        key_id: KeyIdRaw,
        iv_data: *const u8,
        iv_size: u32,
        buffer_data: *mut u8,
        buffer_size: u32,
        plaintext_size: u32,
    },
    EncryptAesCbcExternalKey {
        key_data: *const u8,
        key_size: u32,
        iv_data: *const u8,
        iv_size: u32,
        buffer_data: *mut u8,
        buffer_size: u32,
        plaintext_size: u32,
    },
    DecryptAesCbc {
        key_id: KeyIdRaw,
        iv_data: *const u8,
        iv_size: u32,
        buffer_data: *mut u8,
        buffer_size: u32,
    },
    DecryptAesCbcExternalKey {
        key_data: *const u8,
        key_size: u32,
        iv_data: *const u8,
        iv_size: u32,
        buffer_data: *mut u8,
        buffer_size: u32,
    },
    CalculateAesCmac {
        key_id: KeyIdRaw,
        message_data: *const u8,
        message_size: u32,
        tag_data: *mut u8,
        tag_size: u32,
    },
    CalculateAesCmacExternalKey {
        key_data: *const u8,
        key_size: u32,
        message_data: *const u8,
        message_size: u32,
        tag_data: *mut u8,
        tag_size: u32,
    },
    VerifyAesCmac {
        key_id: KeyIdRaw,
        message_data: *const u8,
        message_size: u32,
        tag_data: *const u8,
        tag_size: u32,
    },
    VerifyAesCmacExternalKey {
        key_data: *const u8,
        key_size: u32,
        message_data: *const u8,
        message_size: u32,
        tag_data: *const u8,
        tag_size: u32,
    },
    CalculateHmac {
        key_id: KeyIdRaw,
        hash_algorithm: HashAlgorithmRaw,
        message_data: *const u8,
        message_size: u32,
        tag_data: *mut u8,
        tag_size: u32,
    },
    CalculateHmacExternalKey {
        key_data: *const u8,
        key_size: u32,
        hash_algorithm: HashAlgorithmRaw,
        message_data: *const u8,
        message_size: u32,
        tag_data: *mut u8,
        tag_size: u32,
    },
    VerifyHmac {
        key_id: KeyIdRaw,
        hash_algorithm: HashAlgorithmRaw,
        message_data: *const u8,
        message_size: u32,
        tag_data: *const u8,
        tag_size: u32,
    },
    VerifyHmacExternalKey {
        key_data: *const u8,
        key_size: u32,
        hash_algorithm: HashAlgorithmRaw,
        message_data: *const u8,
        message_size: u32,
        tag_data: *const u8,
        tag_size: u32,
    },
    Sign {
        key_id: KeyIdRaw,
        message_data: *const u8,
        message_size: u32,
        prehashed: BoolRaw,
        signature_data: *mut u8,
        signature_size: u32,
    },
    SignExternalKey {
        key_data: *const u8,
        key_size: u32,
        message_data: *const u8,
        message_size: u32,
        prehashed: BoolRaw,
        signature_data: *mut u8,
        signature_size: u32,
    },
    Verify {
        key_id: KeyIdRaw,
        message_data: *const u8,
        message_size: u32,
        prehashed: BoolRaw,
        signature_data: *const u8,
        signature_size: u32,
    },
    VerifyExternalKey {
        key_data: *const u8,
        key_size: u32,
        message_data: *const u8,
        message_size: u32,
        prehashed: BoolRaw,
        signature_data: *const u8,
        signature_size: u32,
    },
    Ecdh {
        public_key_data: *const u8,
        public_key_size: u32,
        private_key_id: KeyIdRaw,
        shared_secret_data: *mut u8,
        shared_secret_size: u32,
    },
    EcdhExternalPrivateKey {
        curve: CurveRaw,
        public_key_data: *const u8,
        public_key_size: u32,
        private_key_data: *const u8,
        private_key_size: u32,
        shared_secret_data: *mut u8,
        shared_secret_size: u32,
    },
}

/// Raw response as it is written by clients to shared memory. This type is supposed to be synced
/// with non-Rust (e.g. C++) clients via cbindgen.
#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct ResponseRaw {
    client_id: ClientIdRaw,
    request_id: RequestIdRaw,
    data: ResponseDataRaw,
}

/// Raw response as it is written by clients to shared memory. This type is supposed to be synced
/// with non-Rust (e.g. C++) clients via cbindgen.
#[repr(C, u8)]
#[derive(Clone, Copy, Debug, EnumCount)]
pub enum ResponseDataRaw {
    Error {
        error: JobErrorRaw,
    },
    GetRandom {
        data_data: *mut u8,
        data_size: u32,
    },
    GenerateSymmetricKey {},
    GenerateKeyPair {},
    ImportSymmetricKey {},
    ImportKeyPair {},
    ExportSymmetricKey {
        key_data: *mut u8,
        key_size: u32,
    },
    ExportPublicKey {
        public_key_data: *mut u8,
        public_key_size: u32,
    },
    ExportPrivateKey {
        private_key_data: *mut u8,
        private_key_size: u32,
    },
    IsKeyAvailable {
        is_available: u32,
    },
    EncryptChaChaPoly {
        buffer_data: *mut u8,
        buffer_size: u32,
        tag_data: *mut u8,
        tag_size: u32,
    },
    DecryptChaChaPoly {
        buffer_data: *mut u8,
        buffer_size: u32,
    },
    EncryptAesGcm {
        buffer_data: *mut u8,
        buffer_size: u32,
        tag_data: *mut u8,
        tag_size: u32,
    },
    DecryptAesGcm {
        buffer_data: *mut u8,
        buffer_size: u32,
    },
    EncryptAesCbc {
        buffer_data: *mut u8,
        buffer_size: u32,
    },
    DecryptAesCbc {
        buffer_data: *mut u8,
        buffer_size: u32,
    },
    CalculateAesCmac {
        tag_data: *mut u8,
        tag_size: u32,
    },
    VerifyAesCmac {
        verified: BoolRaw,
    },
    CalculateHmac {
        tag_data: *mut u8,
        tag_size: u32,
    },
    VerifyHmac {
        verified: BoolRaw,
    },
    Sign {
        signature_data: *mut u8,
        signature_size: u32,
    },
    Verify {
        verified: BoolRaw,
    },
    Ecdh {
        shared_secret_data: *mut u8,
        shared_secret_size: u32,
    },
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum ValidationError {
    InvalidPointer,
    InvalidTagValue,
    InvalidValue,
}

impl RequestResponseRawPair {
    /// Create a `RequestResponseRawPair` from a raw pointer.
    ///
    /// # Arguments
    ///
    /// * `ptr`: The pointer to the first byte of the `RequestResponseRawPair`
    ///
    /// # Safety
    ///
    /// The provided pointer must be valid (non-null, aligned, point to valid memory) and point to a
    /// valid `RequestResponseRawPair` instance.  
    ///
    pub unsafe fn from_raw(ptr: *const u8) -> Result<Self, ValidationError> {
        let request = RequestRaw::from_raw(ptr)?;
        let response_ptr = ptr.add(core::mem::size_of::<RequestRaw>());
        let response = ResponseRaw::from_raw(response_ptr)?;
        Ok(RequestResponseRawPair { request, response })
    }
}

impl RequestRaw {
    /// Create a `RequestRaw` from a raw pointer.
    ///
    /// # Arguments
    ///
    /// * `ptr`: The pointer to the first byte of the `RequestRaw`
    ///
    /// # Safety
    ///
    /// The provided pointer must be valid (non-null, aligned, point to valid memory) and point to a
    /// valid `RequestRaw` instance.  
    ///
    pub unsafe fn from_raw(ptr: *const u8) -> Result<Self, ValidationError> {
        // SAFETY: Pointer and size must be checked by integrator
        let tag: u8 = unsafe { *(ptr.add(offset_of!(RequestRaw, data))) };

        // Validate tag value. Invalid tag values cause UB when transmuted into an enum.
        if tag >= RequestDataRaw::COUNT as u8 {
            return Err(ValidationError::InvalidTagValue);
        }

        // SAFETY: All members of RequestRaw are valid for all possible values found in memory
        Ok(*ptr.cast::<RequestRaw>())
    }

    pub fn verify<'data>(
        self,
        validator: &impl Fn(*const u8, u32) -> bool,
    ) -> Result<Request<'data>, ValidationError> {
        let client_id = self.client_id.into();
        let request_id = self.request_id.into();
        let request = match self.data {
            RequestDataRaw::GetRandom {
                output_data,
                output_size,
            } => Request::GetRandom {
                client_id,
                request_id,
                output: check_mut_pointer_and_size(output_data, output_size, &validator)?,
            },
            RequestDataRaw::GenerateSymmetricKey { key_id, overwrite } => {
                Request::GenerateSymmetricKey {
                    client_id,
                    request_id,
                    key_id: key_id.into(),
                    overwrite: bool_raw_to_bool(overwrite),
                }
            }
            RequestDataRaw::GenerateKeyPair { key_id, overwrite } => Request::GenerateKeyPair {
                client_id,
                request_id,
                key_id: key_id.into(),
                overwrite: bool_raw_to_bool(overwrite),
            },
            RequestDataRaw::ImportSymmetricKey {
                key_id,
                data_data,
                data_size,
                overwrite,
            } => Request::ImportSymmetricKey {
                client_id,
                request_id,
                key_id: key_id.into(),
                data: check_pointer_and_size(data_data, data_size, &validator)?,
                overwrite: bool_raw_to_bool(overwrite),
            },
            RequestDataRaw::ImportKeyPair {
                key_id,
                public_key_data,
                public_key_size,
                private_key_data,
                private_key_size,
                overwrite,
            } => Request::ImportKeyPair {
                client_id,
                request_id,
                key_id: key_id.into(),
                public_key: check_pointer_and_size(public_key_data, public_key_size, &validator)?,
                private_key: check_pointer_and_size(
                    private_key_data,
                    private_key_size,
                    &validator,
                )?,
                overwrite: bool_raw_to_bool(overwrite),
            },
            RequestDataRaw::ExportSymmetricKey {
                key_id,
                data_data,
                data_size,
            } => Request::ExportSymmetricKey {
                client_id,
                request_id,
                key_id: key_id.into(),
                data: check_mut_pointer_and_size(data_data, data_size, &validator)?,
            },
            RequestDataRaw::ExportPublicKey {
                key_id,
                public_key_data,
                public_key_size,
            } => Request::ExportPublicKey {
                client_id,
                request_id,
                key_id: key_id.into(),
                public_key: check_mut_pointer_and_size(
                    public_key_data,
                    public_key_size,
                    &validator,
                )?,
            },
            RequestDataRaw::ExportPrivateKey {
                key_id,
                private_key_data,
                private_key_size,
            } => Request::ExportPrivateKey {
                client_id,
                request_id,
                key_id: key_id.into(),
                private_key: check_mut_pointer_and_size(
                    private_key_data,
                    private_key_size,
                    &validator,
                )?,
            },
            RequestDataRaw::IsKeyAvailable { key_id } => Request::IsKeyAvailable {
                client_id,
                request_id,
                key_id: key_id.into(),
            },
            RequestDataRaw::EncryptChaChaPoly {
                key_id,
                nonce_data,
                nonce_size,
                buffer_data,
                buffer_size,
                aad_data,
                aad_size,
                tag_data,
                tag_size,
            } => Request::EncryptChaChaPoly {
                client_id,
                request_id,
                key_id: key_id.into(),
                nonce: check_pointer_and_size(nonce_data, nonce_size, &validator)?,
                buffer: check_mut_pointer_and_size(buffer_data, buffer_size, &validator)?,
                aad: check_pointer_and_size(aad_data, aad_size, &validator)?,
                tag: check_mut_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::EncryptChaChaPolyExternalKey {
                key_data,
                key_size,
                nonce_data,
                nonce_size,
                buffer_data,
                buffer_size,
                aad_data,
                aad_size,
                tag_data,
                tag_size,
            } => Request::EncryptChaChaPolyExternalKey {
                client_id,
                request_id,
                key: check_pointer_and_size(key_data, key_size, &validator)?,
                nonce: check_pointer_and_size(nonce_data, nonce_size, &validator)?,
                buffer: check_mut_pointer_and_size(buffer_data, buffer_size, &validator)?,
                aad: check_pointer_and_size(aad_data, aad_size, &validator)?,
                tag: check_mut_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::DecryptChaChaPoly {
                key_id,
                nonce_data,
                nonce_size,
                buffer_data,
                buffer_size,
                aad_data,
                aad_size,
                tag_data,
                tag_size,
            } => Request::DecryptChaChaPoly {
                client_id,
                request_id,
                key_id: key_id.into(),
                nonce: check_pointer_and_size(nonce_data, nonce_size, &validator)?,
                buffer: check_mut_pointer_and_size(buffer_data, buffer_size, &validator)?,
                aad: check_pointer_and_size(aad_data, aad_size, &validator)?,
                tag: check_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::DecryptChaChaPolyExternalKey {
                key_data,
                key_size,
                nonce_data,
                nonce_size,
                buffer_data,
                buffer_size,
                aad_data,
                aad_size,
                tag_data,
                tag_size,
            } => Request::DecryptChaChaPolyExternalKey {
                client_id,
                request_id,
                key: check_pointer_and_size(key_data, key_size, &validator)?,
                nonce: check_pointer_and_size(nonce_data, nonce_size, &validator)?,
                buffer: check_mut_pointer_and_size(buffer_data, buffer_size, &validator)?,
                aad: check_pointer_and_size(aad_data, aad_size, &validator)?,
                tag: check_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::EncryptAesGcm {
                key_id,
                iv_data,
                iv_size,
                buffer_data,
                buffer_size,
                aad_data,
                aad_size,
                tag_data,
                tag_size,
            } => Request::EncryptAesGcm {
                client_id,
                request_id,
                key_id: key_id.into(),
                iv: check_pointer_and_size(iv_data, iv_size, &validator)?,
                buffer: check_mut_pointer_and_size(buffer_data, buffer_size, &validator)?,
                aad: check_pointer_and_size(aad_data, aad_size, &validator)?,
                tag: check_mut_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::EncryptAesGcmExternalKey {
                key_data,
                key_size,
                iv_data,
                iv_size,
                buffer_data,
                buffer_size,
                aad_data,
                aad_size,
                tag_data,
                tag_size,
            } => Request::EncryptAesGcmExternalKey {
                client_id,
                request_id,
                key: check_pointer_and_size(key_data, key_size, &validator)?,
                iv: check_pointer_and_size(iv_data, iv_size, &validator)?,
                buffer: check_mut_pointer_and_size(buffer_data, buffer_size, &validator)?,
                aad: check_pointer_and_size(aad_data, aad_size, &validator)?,
                tag: check_mut_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::DecryptAesGcm {
                key_id,
                iv_data,
                iv_size,
                buffer_data,
                buffer_size,
                aad_data,
                aad_size,
                tag_data,
                tag_size,
            } => Request::DecryptAesGcm {
                client_id,
                request_id,
                key_id: key_id.into(),
                iv: check_pointer_and_size(iv_data, iv_size, &validator)?,
                buffer: check_mut_pointer_and_size(buffer_data, buffer_size, &validator)?,
                aad: check_pointer_and_size(aad_data, aad_size, &validator)?,
                tag: check_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::DecryptAesGcmExternalKey {
                key_data,
                key_size,
                iv_data,
                iv_size,
                buffer_data,
                buffer_size,
                aad_data,
                aad_size,
                tag_data,
                tag_size,
            } => Request::DecryptAesGcmExternalKey {
                client_id,
                request_id,
                key: check_pointer_and_size(key_data, key_size, &validator)?,
                iv: check_pointer_and_size(iv_data, iv_size, &validator)?,
                buffer: check_mut_pointer_and_size(buffer_data, buffer_size, &validator)?,
                aad: check_pointer_and_size(aad_data, aad_size, &validator)?,
                tag: check_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::EncryptAesCbc {
                key_id,
                iv_data,
                iv_size,
                buffer_data,
                buffer_size,
                plaintext_size,
            } => Request::EncryptAesCbc {
                client_id,
                request_id,
                key_id: key_id.into(),
                iv: check_pointer_and_size(iv_data, iv_size, &validator)?,
                buffer: check_mut_pointer_and_size(buffer_data, buffer_size, &validator)?,
                plaintext_size: plaintext_size as usize,
            },
            RequestDataRaw::EncryptAesCbcExternalKey {
                key_data,
                key_size,
                iv_data,
                iv_size,
                buffer_data,
                buffer_size,
                plaintext_size,
            } => Request::EncryptAesCbcExternalKey {
                client_id,
                request_id,
                key: check_pointer_and_size(key_data, key_size, &validator)?,
                iv: check_pointer_and_size(iv_data, iv_size, &validator)?,
                buffer: check_mut_pointer_and_size(buffer_data, buffer_size, &validator)?,
                plaintext_size: plaintext_size as usize,
            },
            RequestDataRaw::DecryptAesCbc {
                key_id,
                iv_data,
                iv_size,
                buffer_data,
                buffer_size,
            } => Request::DecryptAesCbc {
                client_id,
                request_id,
                key_id: key_id.into(),
                iv: check_pointer_and_size(iv_data, iv_size, &validator)?,
                buffer: check_mut_pointer_and_size(buffer_data, buffer_size, &validator)?,
            },
            RequestDataRaw::DecryptAesCbcExternalKey {
                key_data,
                key_size,
                iv_data,
                iv_size,
                buffer_data,
                buffer_size,
            } => Request::DecryptAesCbcExternalKey {
                client_id,
                request_id,
                key: check_pointer_and_size(key_data, key_size, &validator)?,
                iv: check_pointer_and_size(iv_data, iv_size, &validator)?,
                buffer: check_mut_pointer_and_size(buffer_data, buffer_size, &validator)?,
            },
            RequestDataRaw::CalculateAesCmac {
                key_id,
                message_data,
                message_size,
                tag_data,
                tag_size,
            } => Request::CalculateAesCmac {
                client_id,
                request_id,
                key_id: key_id.into(),
                message: check_pointer_and_size(message_data, message_size, &validator)?,
                tag: check_mut_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::CalculateAesCmacExternalKey {
                key_data,
                key_size,
                message_data,
                message_size,
                tag_data,
                tag_size,
            } => Request::CalculateAesCmacExternalKey {
                client_id,
                request_id,
                key: check_pointer_and_size(key_data, key_size, &validator)?,
                message: check_pointer_and_size(message_data, message_size, &validator)?,
                tag: check_mut_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::VerifyAesCmac {
                key_id,
                message_data,
                message_size,
                tag_data,
                tag_size,
            } => Request::VerifyAesCmac {
                client_id,
                request_id,
                key_id: key_id.into(),
                message: check_pointer_and_size(message_data, message_size, &validator)?,
                tag: check_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::VerifyAesCmacExternalKey {
                key_data,
                key_size,
                message_data,
                message_size,
                tag_data,
                tag_size,
            } => Request::VerifyAesCmacExternalKey {
                client_id,
                request_id,
                key: check_pointer_and_size(key_data, key_size, &validator)?,
                message: check_pointer_and_size(message_data, message_size, &validator)?,
                tag: check_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::CalculateHmac {
                key_id,
                hash_algorithm,
                message_data,
                message_size,
                tag_data,
                tag_size,
            } => Request::CalculateHmac {
                client_id,
                request_id,
                key_id: key_id.into(),
                hash_algorithm: hash_algorithm.try_into()?,
                message: check_pointer_and_size(message_data, message_size, &validator)?,
                tag: check_mut_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::CalculateHmacExternalKey {
                key_data,
                key_size,
                hash_algorithm,
                message_data,
                message_size,
                tag_data,
                tag_size,
            } => Request::CalculateHmacExternalKey {
                client_id,
                request_id,
                key: check_pointer_and_size(key_data, key_size, &validator)?,
                hash_algorithm: hash_algorithm.try_into()?,
                message: check_pointer_and_size(message_data, message_size, &validator)?,
                tag: check_mut_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::VerifyHmac {
                key_id,
                hash_algorithm,
                message_data,
                message_size,
                tag_data,
                tag_size,
            } => Request::VerifyHmac {
                client_id,
                request_id,
                key_id: key_id.into(),
                hash_algorithm: hash_algorithm.try_into()?,
                message: check_pointer_and_size(message_data, message_size, &validator)?,
                tag: check_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::VerifyHmacExternalKey {
                key_data,
                key_size,
                hash_algorithm,
                message_data,
                message_size,
                tag_data,
                tag_size,
            } => Request::VerifyHmacExternalKey {
                client_id,
                request_id,
                key: check_pointer_and_size(key_data, key_size, &validator)?,
                hash_algorithm: hash_algorithm.try_into()?,
                message: check_pointer_and_size(message_data, message_size, &validator)?,
                tag: check_pointer_and_size(tag_data, tag_size, &validator)?,
            },
            RequestDataRaw::Sign {
                key_id,
                message_data,
                message_size,
                prehashed,
                signature_data,
                signature_size,
            } => Request::Sign {
                client_id,
                request_id,
                key_id: key_id.into(),
                message: check_pointer_and_size(message_data, message_size, &validator)?,
                prehashed: bool_raw_to_bool(prehashed),
                signature: check_mut_pointer_and_size(signature_data, signature_size, &validator)?,
            },
            RequestDataRaw::SignExternalKey {
                key_data,
                key_size,
                message_data,
                message_size,
                prehashed,
                signature_data,
                signature_size,
            } => Request::SignExternalKey {
                client_id,
                request_id,
                private_key: check_pointer_and_size(key_data, key_size, &validator)?,
                message: check_pointer_and_size(message_data, message_size, &validator)?,
                prehashed: bool_raw_to_bool(prehashed),
                signature: check_mut_pointer_and_size(signature_data, signature_size, &validator)?,
            },
            RequestDataRaw::Verify {
                key_id,
                message_data,
                message_size,
                prehashed,
                signature_data,
                signature_size,
            } => Request::Verify {
                client_id,
                request_id,
                key_id: key_id.into(),
                message: check_pointer_and_size(message_data, message_size, &validator)?,
                prehashed: bool_raw_to_bool(prehashed),
                signature: check_pointer_and_size(signature_data, signature_size, &validator)?,
            },
            RequestDataRaw::VerifyExternalKey {
                key_data,
                key_size,
                message_data,
                message_size,
                prehashed,
                signature_data,
                signature_size,
            } => Request::VerifyExternalKey {
                client_id,
                request_id,
                public_key: check_pointer_and_size(key_data, key_size, &validator)?,
                message: check_pointer_and_size(message_data, message_size, &validator)?,
                prehashed: bool_raw_to_bool(prehashed),
                signature: check_pointer_and_size(signature_data, signature_size, &validator)?,
            },
            RequestDataRaw::Ecdh {
                public_key_data,
                public_key_size,
                private_key_id,
                shared_secret_data,
                shared_secret_size,
            } => Request::Ecdh {
                client_id,
                request_id,
                public_key: check_pointer_and_size(public_key_data, public_key_size, &validator)?,
                private_key_id: private_key_id.into(),
                shared_secret: check_mut_pointer_and_size(
                    shared_secret_data,
                    shared_secret_size,
                    &validator,
                )?,
            },
            RequestDataRaw::EcdhExternalPrivateKey {
                curve,
                public_key_data,
                public_key_size,
                private_key_data,
                private_key_size,
                shared_secret_data,
                shared_secret_size,
            } => Request::EcdhExternalPrivateKey {
                client_id,
                request_id,
                curve: curve.try_into()?,
                public_key: check_pointer_and_size(public_key_data, public_key_size, &validator)?,
                private_key: check_pointer_and_size(
                    private_key_data,
                    private_key_size,
                    &validator,
                )?,
                shared_secret: check_mut_pointer_and_size(
                    shared_secret_data,
                    shared_secret_size,
                    &validator,
                )?,
            },
        };
        Ok(request)
    }
}

// Outgoing direction. No validation needed.
impl From<Request<'_>> for RequestRaw {
    fn from(request: Request) -> Self {
        match request {
            Request::GetRandom {
                client_id,
                request_id,
                output,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::GetRandom {
                    output_data: output.as_mut_ptr(),
                    output_size: output.len() as u32,
                },
            },
            Request::GenerateSymmetricKey {
                client_id,
                request_id,
                key_id,
                overwrite,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::GenerateSymmetricKey {
                    key_id: key_id.into(),
                    overwrite: overwrite.into(),
                },
            },
            Request::GenerateKeyPair {
                client_id,
                request_id,
                key_id,
                overwrite,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::GenerateKeyPair {
                    key_id: key_id.into(),
                    overwrite: overwrite.into(),
                },
            },
            Request::ImportSymmetricKey {
                client_id,
                request_id,
                key_id,
                data,
                overwrite,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::ImportSymmetricKey {
                    key_id: key_id.into(),
                    data_data: data.as_ptr(),
                    data_size: data.len() as u32,
                    overwrite: overwrite.into(),
                },
            },
            Request::ImportKeyPair {
                client_id,
                request_id,
                key_id,
                public_key,
                private_key,
                overwrite,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::ImportKeyPair {
                    key_id: key_id.into(),
                    public_key_data: public_key.as_ptr(),
                    public_key_size: public_key.len() as u32,
                    private_key_data: private_key.as_ptr(),
                    private_key_size: private_key.len() as u32,
                    overwrite: overwrite.into(),
                },
            },
            Request::ExportSymmetricKey {
                client_id,
                request_id,
                key_id,
                data,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::ExportSymmetricKey {
                    key_id: key_id.into(),
                    data_data: data.as_mut_ptr(),
                    data_size: data.len() as u32,
                },
            },
            Request::ExportPublicKey {
                client_id,
                request_id,
                key_id,
                public_key,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::ExportPublicKey {
                    key_id: key_id.into(),
                    public_key_data: public_key.as_mut_ptr(),
                    public_key_size: public_key.len() as u32,
                },
            },
            Request::ExportPrivateKey {
                client_id,
                request_id,
                key_id,
                private_key,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::ExportPrivateKey {
                    key_id: key_id.into(),
                    private_key_data: private_key.as_mut_ptr(),
                    private_key_size: private_key.len() as u32,
                },
            },
            Request::IsKeyAvailable {
                client_id,
                request_id,
                key_id,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::IsKeyAvailable {
                    key_id: key_id.into(),
                },
            },
            Request::EncryptChaChaPoly {
                client_id,
                request_id,
                key_id,
                nonce,
                buffer,
                aad,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::EncryptChaChaPoly {
                    key_id: key_id.into(),
                    nonce_data: nonce.as_ptr(),
                    nonce_size: nonce.len() as u32,
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                    aad_data: aad.as_ptr(),
                    aad_size: aad.len() as u32,
                    tag_data: tag.as_mut_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::EncryptChaChaPolyExternalKey {
                client_id,
                request_id,
                key,
                nonce,
                buffer,
                aad,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::EncryptChaChaPolyExternalKey {
                    key_data: key.as_ptr(),
                    key_size: key.len() as u32,
                    nonce_data: nonce.as_ptr(),
                    nonce_size: nonce.len() as u32,
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                    aad_data: aad.as_ptr(),
                    aad_size: aad.len() as u32,
                    tag_data: tag.as_mut_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::DecryptChaChaPoly {
                client_id,
                request_id,
                key_id,
                nonce,
                buffer,
                aad,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::DecryptChaChaPoly {
                    key_id: key_id.into(),
                    nonce_data: nonce.as_ptr(),
                    nonce_size: nonce.len() as u32,
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                    aad_data: aad.as_ptr(),
                    aad_size: aad.len() as u32,
                    tag_data: tag.as_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::DecryptChaChaPolyExternalKey {
                client_id,
                request_id,
                key,
                nonce,
                buffer,
                aad,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::DecryptChaChaPolyExternalKey {
                    key_data: key.as_ptr(),
                    key_size: key.len() as u32,
                    nonce_data: nonce.as_ptr(),
                    nonce_size: nonce.len() as u32,
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                    aad_data: aad.as_ptr(),
                    aad_size: aad.len() as u32,
                    tag_data: tag.as_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::EncryptAesGcm {
                client_id,
                request_id,
                key_id,
                iv,
                buffer,
                aad,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::EncryptAesGcm {
                    key_id: key_id.into(),
                    iv_data: iv.as_ptr(),
                    iv_size: iv.len() as u32,
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                    aad_data: aad.as_ptr(),
                    aad_size: aad.len() as u32,
                    tag_data: tag.as_mut_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::EncryptAesGcmExternalKey {
                client_id,
                request_id,
                key,
                iv,
                buffer,
                aad,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::EncryptAesGcmExternalKey {
                    key_data: key.as_ptr(),
                    key_size: key.len() as u32,
                    iv_data: iv.as_ptr(),
                    iv_size: iv.len() as u32,
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                    aad_data: aad.as_ptr(),
                    aad_size: aad.len() as u32,
                    tag_data: tag.as_mut_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::DecryptAesGcm {
                client_id,
                request_id,
                key_id,
                iv,
                buffer,
                aad,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::DecryptAesGcm {
                    key_id: key_id.into(),
                    iv_data: iv.as_ptr(),
                    iv_size: iv.len() as u32,
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                    aad_data: aad.as_ptr(),
                    aad_size: aad.len() as u32,
                    tag_data: tag.as_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::DecryptAesGcmExternalKey {
                client_id,
                request_id,
                key,
                iv,
                buffer,
                aad,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::DecryptAesGcmExternalKey {
                    key_data: key.as_ptr(),
                    key_size: key.len() as u32,
                    iv_data: iv.as_ptr(),
                    iv_size: iv.len() as u32,
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                    aad_data: aad.as_ptr(),
                    aad_size: aad.len() as u32,
                    tag_data: tag.as_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::EncryptAesCbc {
                client_id,
                request_id,
                key_id,
                iv,
                buffer,
                plaintext_size,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::EncryptAesCbc {
                    key_id: key_id.into(),
                    iv_data: iv.as_ptr(),
                    iv_size: iv.len() as u32,
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                    plaintext_size: plaintext_size as u32,
                },
            },
            Request::EncryptAesCbcExternalKey {
                client_id,
                request_id,
                key,
                iv,
                buffer,
                plaintext_size,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::EncryptAesCbcExternalKey {
                    key_data: key.as_ptr(),
                    key_size: key.len() as u32,
                    iv_data: iv.as_ptr(),
                    iv_size: iv.len() as u32,
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                    plaintext_size: plaintext_size as u32,
                },
            },
            Request::DecryptAesCbc {
                client_id,
                request_id,
                key_id,
                iv,
                buffer,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::DecryptAesCbc {
                    key_id: key_id.into(),
                    iv_data: iv.as_ptr(),
                    iv_size: iv.len() as u32,
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                },
            },
            Request::DecryptAesCbcExternalKey {
                client_id,
                request_id,
                key,
                iv,
                buffer,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::DecryptAesCbcExternalKey {
                    key_data: key.as_ptr(),
                    key_size: key.len() as u32,
                    iv_data: iv.as_ptr(),
                    iv_size: iv.len() as u32,
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                },
            },
            Request::CalculateAesCmac {
                client_id,
                request_id,
                key_id,
                message,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::CalculateAesCmac {
                    key_id: key_id.into(),
                    message_data: message.as_ptr(),
                    message_size: message.len() as u32,
                    tag_data: tag.as_mut_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::CalculateAesCmacExternalKey {
                client_id,
                request_id,
                key,
                message,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::CalculateAesCmacExternalKey {
                    key_data: key.as_ptr(),
                    key_size: key.len() as u32,
                    message_data: message.as_ptr(),
                    message_size: message.len() as u32,
                    tag_data: tag.as_mut_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::VerifyAesCmac {
                client_id,
                request_id,
                key_id,
                message,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::VerifyAesCmac {
                    key_id: key_id.into(),
                    message_data: message.as_ptr(),
                    message_size: message.len() as u32,
                    tag_data: tag.as_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::VerifyAesCmacExternalKey {
                client_id,
                request_id,
                key,
                message,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::VerifyAesCmacExternalKey {
                    key_data: key.as_ptr(),
                    key_size: key.len() as u32,
                    message_data: message.as_ptr(),
                    message_size: message.len() as u32,
                    tag_data: tag.as_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::CalculateHmac {
                client_id,
                request_id,
                key_id,
                hash_algorithm,
                message,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::CalculateHmac {
                    key_id: key_id.into(),
                    hash_algorithm: hash_algorithm.into(),
                    message_data: message.as_ptr(),
                    message_size: message.len() as u32,
                    tag_data: tag.as_mut_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::CalculateHmacExternalKey {
                client_id,
                request_id,
                key,
                hash_algorithm,
                message,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::CalculateHmacExternalKey {
                    key_data: key.as_ptr(),
                    key_size: key.len() as u32,
                    hash_algorithm: hash_algorithm.into(),
                    message_data: message.as_ptr(),
                    message_size: message.len() as u32,
                    tag_data: tag.as_mut_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::VerifyHmac {
                client_id,
                request_id,
                key_id,
                hash_algorithm,
                message,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::VerifyHmac {
                    key_id: key_id.into(),
                    hash_algorithm: hash_algorithm.into(),
                    message_data: message.as_ptr(),
                    message_size: message.len() as u32,
                    tag_data: tag.as_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::VerifyHmacExternalKey {
                client_id,
                request_id,
                key,
                hash_algorithm,
                message,
                tag,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::VerifyHmacExternalKey {
                    key_data: key.as_ptr(),
                    key_size: key.len() as u32,
                    hash_algorithm: hash_algorithm.into(),
                    message_data: message.as_ptr(),
                    message_size: message.len() as u32,
                    tag_data: tag.as_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Request::Sign {
                client_id,
                request_id,
                key_id,
                message,
                prehashed,
                signature,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::Sign {
                    key_id: key_id.into(),
                    message_data: message.as_ptr(),
                    message_size: message.len() as u32,
                    prehashed: prehashed.into(),
                    signature_data: signature.as_mut_ptr(),
                    signature_size: signature.len() as u32,
                },
            },
            Request::SignExternalKey {
                client_id,
                request_id,
                private_key: key,
                message,
                prehashed,
                signature,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::SignExternalKey {
                    key_data: key.as_ptr(),
                    key_size: key.len() as u32,
                    message_data: message.as_ptr(),
                    message_size: message.len() as u32,
                    prehashed: prehashed.into(),
                    signature_data: signature.as_mut_ptr(),
                    signature_size: signature.len() as u32,
                },
            },
            Request::Verify {
                client_id,
                request_id,
                key_id,
                message,
                prehashed,
                signature,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::Verify {
                    key_id: key_id.into(),
                    message_data: message.as_ptr(),
                    message_size: message.len() as u32,
                    prehashed: prehashed.into(),
                    signature_data: signature.as_ptr(),
                    signature_size: signature.len() as u32,
                },
            },
            Request::VerifyExternalKey {
                client_id,
                request_id,
                public_key: key,
                message,
                prehashed,
                signature,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::VerifyExternalKey {
                    key_data: key.as_ptr(),
                    key_size: key.len() as u32,
                    message_data: message.as_ptr(),
                    message_size: message.len() as u32,
                    prehashed: prehashed.into(),
                    signature_data: signature.as_ptr(),
                    signature_size: signature.len() as u32,
                },
            },
            Request::Ecdh {
                client_id,
                request_id,
                public_key,
                private_key_id,
                shared_secret,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::Ecdh {
                    public_key_data: public_key.as_ptr(),
                    public_key_size: public_key.len() as u32,
                    private_key_id: private_key_id.into(),
                    shared_secret_data: shared_secret.as_mut_ptr(),
                    shared_secret_size: shared_secret.len() as u32,
                },
            },
            Request::EcdhExternalPrivateKey {
                client_id,
                request_id,
                curve,
                public_key,
                private_key,
                shared_secret,
            } => RequestRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: RequestDataRaw::EcdhExternalPrivateKey {
                    curve: curve.into(),
                    public_key_data: public_key.as_ptr(),
                    public_key_size: public_key.len() as u32,
                    private_key_data: private_key.as_ptr(),
                    private_key_size: private_key.len() as u32,
                    shared_secret_data: shared_secret.as_mut_ptr(),
                    shared_secret_size: shared_secret.len() as u32,
                },
            },
        }
    }
}

// Outgoing direction. No validation needed.
impl ResponseRaw {
    /// Create a `ResponseRaw` from a raw pointer.
    ///
    /// # Arguments
    ///
    /// * `ptr`: The pointer to the first byte of the `ResponseRaw`
    ///
    /// # Safety
    ///
    /// The provided pointer must be valid (non-null, aligned, point to valid memory) and point to a
    /// valid `ResponseRaw` instance.  
    ///
    pub unsafe fn from_raw(ptr: *const u8) -> Result<Self, ValidationError> {
        // SAFETY: Pointer and size must be checked by integrator
        let tag: u8 = unsafe { *(ptr.add(offset_of!(RequestRaw, data))) };

        // Validate tag value. Invalid tag values cause UB when transmuted into an enum.
        if tag >= ResponseDataRaw::COUNT as u8 {
            return Err(ValidationError::InvalidTagValue);
        }

        // SAFETY: All members of RequestRaw are valid for all possible values found in memory
        Ok(*ptr.cast::<ResponseRaw>())
    }
}

impl From<Response<'_>> for ResponseRaw {
    fn from(value: Response<'_>) -> Self {
        match value {
            Response::Error {
                client_id,
                request_id,
                error,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::Error {
                    error: error.into(),
                },
            },
            Response::GetRandom {
                client_id,
                request_id,
                data,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::GetRandom {
                    data_data: data.as_mut_ptr(),
                    data_size: data.len() as u32,
                },
            },
            Response::GenerateSymmetricKey {
                client_id,
                request_id,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::GenerateSymmetricKey {},
            },
            Response::GenerateKeyPair {
                client_id,
                request_id,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::GenerateKeyPair {},
            },
            Response::ImportSymmetricKey {
                client_id,
                request_id,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::ImportSymmetricKey {},
            },
            Response::ImportKeyPair {
                client_id,
                request_id,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::ImportKeyPair {},
            },
            Response::ExportSymmetricKey {
                client_id,
                request_id,
                key,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::ExportSymmetricKey {
                    key_data: key.as_mut_ptr(),
                    key_size: key.len() as u32,
                },
            },
            Response::ExportPublicKey {
                client_id,
                request_id,
                public_key,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::ExportPublicKey {
                    public_key_data: public_key.as_mut_ptr(),
                    public_key_size: public_key.len() as u32,
                },
            },
            Response::ExportPrivateKey {
                client_id,
                request_id,
                private_key,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::ExportPrivateKey {
                    private_key_data: private_key.as_mut_ptr(),
                    private_key_size: private_key.len() as u32,
                },
            },
            Response::IsKeyAvailable {
                client_id,
                request_id,
                is_available,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::IsKeyAvailable {
                    is_available: is_available.into(),
                },
            },
            Response::EncryptChaChaPoly {
                client_id,
                request_id,
                buffer,
                tag,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::EncryptChaChaPoly {
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                    tag_data: tag.as_mut_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Response::DecryptChaChaPoly {
                client_id,
                request_id,
                buffer,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::DecryptChaChaPoly {
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                },
            },
            Response::EncryptAesGcm {
                client_id,
                request_id,
                buffer,
                tag,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::EncryptAesGcm {
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                    tag_data: tag.as_mut_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Response::DecryptAesGcm {
                client_id,
                request_id,
                buffer,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::DecryptAesGcm {
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                },
            },
            Response::EncryptAesCbc {
                client_id,
                request_id,
                buffer,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::EncryptAesCbc {
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                },
            },
            Response::DecryptAesCbc {
                client_id,
                request_id,
                plaintext: buffer,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::DecryptAesCbc {
                    buffer_data: buffer.as_mut_ptr(),
                    buffer_size: buffer.len() as u32,
                },
            },
            Response::CalculateAesCmac {
                client_id,
                request_id,
                tag,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::CalculateAesCmac {
                    tag_data: tag.as_mut_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Response::VerifyAesCmac {
                client_id,
                request_id,
                verified,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::VerifyAesCmac {
                    verified: verified.into(),
                },
            },
            Response::CalculateHmac {
                client_id,
                request_id,
                tag,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::CalculateHmac {
                    tag_data: tag.as_mut_ptr(),
                    tag_size: tag.len() as u32,
                },
            },
            Response::VerifyHmac {
                client_id,
                request_id,
                verified,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::VerifyHmac {
                    verified: verified.into(),
                },
            },
            Response::Sign {
                client_id,
                request_id,
                signature,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::Sign {
                    signature_data: signature.as_mut_ptr(),
                    signature_size: signature.len() as u32,
                },
            },
            Response::Verify {
                client_id,
                request_id,
                verified,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::Verify {
                    verified: verified.into(),
                },
            },
            Response::Ecdh {
                client_id,
                request_id,
                shared_secret,
            } => ResponseRaw {
                client_id: client_id.into(),
                request_id: request_id.into(),
                data: ResponseDataRaw::Ecdh {
                    shared_secret_data: shared_secret.as_mut_ptr(),
                    shared_secret_size: shared_secret.len() as u32,
                },
            },
        }
    }
}

impl From<KeyId> for KeyIdRaw {
    fn from(value: KeyId) -> Self {
        value.0
    }
}

impl From<KeyIdRaw> for KeyId {
    fn from(value: KeyIdRaw) -> Self {
        KeyId(value)
    }
}

impl From<Curve> for CurveRaw {
    fn from(value: Curve) -> Self {
        match value {
            Curve::NistP256 => NIST_P256,
            Curve::NistP384 => NIST_P384,
        }
    }
}

impl TryFrom<CurveRaw> for Curve {
    type Error = ValidationError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            NIST_P256 => Ok(Self::NistP256),
            NIST_P384 => Ok(Self::NistP384),
            _ => Err(ValidationError::InvalidValue),
        }
    }
}

impl From<HashAlgorithm> for HashAlgorithmRaw {
    fn from(value: HashAlgorithm) -> Self {
        match value {
            HashAlgorithm::Sha2_256 => SHA2_256,
            HashAlgorithm::Sha2_384 => SHA2_384,
            HashAlgorithm::Sha2_512 => SHA2_512,
            HashAlgorithm::Sha3_256 => SHA3_256,
            HashAlgorithm::Sha3_384 => SHA3_384,
            HashAlgorithm::Sha3_512 => SHA3_512,
        }
    }
}

impl TryFrom<HashAlgorithmRaw> for HashAlgorithm {
    type Error = ValidationError;

    fn try_from(value: HashAlgorithmRaw) -> Result<Self, Self::Error> {
        match value {
            SHA2_256 => Ok(Self::Sha2_256),
            SHA2_384 => Ok(Self::Sha2_384),
            SHA2_512 => Ok(Self::Sha2_512),
            SHA3_256 => Ok(Self::Sha3_256),
            SHA3_384 => Ok(Self::Sha3_384),
            SHA3_512 => Ok(Self::Sha3_512),
            _ => Err(ValidationError::InvalidValue),
        }
    }
}

/// Check an untrusted pointer and size pair using a provided validator function.
fn check_pointer_and_size<'a>(
    data: *const u8,
    size: u32,
    validator: &impl Fn(*const u8, u32) -> bool,
) -> Result<&'a [u8], ValidationError> {
    if data.is_null() {
        return Err(ValidationError::InvalidPointer);
    }
    if !validator(data, size) {
        return Err(ValidationError::InvalidPointer);
    }
    // SAFETY: Checked by integrator-provided validator
    Ok(unsafe { slice::from_raw_parts(data, size as usize) })
}

/// Check an untrusted pointer and size pair using a provided validator function.
fn check_mut_pointer_and_size<'a>(
    data: *mut u8,
    size: u32,
    validator: &impl Fn(*const u8, u32) -> bool,
) -> Result<&'a mut [u8], ValidationError> {
    if data.is_null() {
        return Err(ValidationError::InvalidPointer);
    }
    if !validator(data, size) {
        return Err(ValidationError::InvalidPointer);
    }
    // SAFETY: Checked by integrator-provided validator
    Ok(unsafe { slice::from_raw_parts_mut(data, size as usize) })
}

fn bool_raw_to_bool(overwrite: BoolRaw) -> bool {
    overwrite != 0
}

/// Function to trigger the generation of `RequestRaw` and `ResponseRaw` definition
#[no_mangle]
pub extern "C" fn trigger_cbindgen_request_response_raw(
    _request: RequestRaw,
    _response: ResponseRaw,
) -> RequestResponseRawPair {
    unreachable!()
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::common::jobs::Request::GetRandom;
    use crate::common::jobs::{ClientId, RequestId};
    use core::{mem, ptr};

    #[test]
    fn test_serialize_deserialize() {
        let client_id = ClientId(5);
        let request_id = RequestId(7);
        let mut shared_memory = [0u8; 16];
        let request = GetRandom {
            client_id,
            request_id,
            output: &mut shared_memory,
        };
        let request_raw: RequestRaw = request.into();
        let request_raw_ptr = &request_raw as *const RequestRaw as *const u8;
        let reconstructed_request_raw = unsafe { RequestRaw::from_raw(request_raw_ptr) }
            .expect("failed to create raw request from pointer.");
        let always_valid = |_data: *const u8, _size: u32| true;
        let reconstructed_request = reconstructed_request_raw
            .verify(&always_valid)
            .expect("failed to verify raw request");
        match reconstructed_request {
            GetRandom {
                client_id: reconstructed_client_id,
                request_id: reconstructed_request_id,
                output: reconstructed_output,
            } => {
                assert_eq!(reconstructed_client_id, client_id);
                assert_eq!(reconstructed_request_id, request_id);
                assert_eq!(reconstructed_output.as_ptr(), shared_memory.as_ptr());
                assert_eq!(reconstructed_output.len(), shared_memory.len());
            }
            _ => {
                panic!("Unexpected reconstructed request type")
            }
        }
    }

    #[test]
    fn test_invalid_buffer_size() {
        let client_id = ClientId(5);
        let request_id = RequestId(7);
        const OUTPUT_SIZE: usize = 16;
        let mut shared_memory = [0u8; mem::size_of::<RequestRaw>() + OUTPUT_SIZE];
        let request_response_start = shared_memory.as_mut_ptr();
        let output_start = unsafe { shared_memory.as_mut_ptr().add(mem::size_of::<RequestRaw>()) };
        let request = GetRandom {
            client_id,
            request_id,
            output: unsafe { slice::from_raw_parts_mut(output_start, OUTPUT_SIZE) },
        };
        let request_raw = request.into();
        let mut request_response_pair =
            unsafe { RequestResponseRawPair::from_raw(request_response_start) }
                .expect("failed to create request-response pair from pointer.");
        request_response_pair.request = request_raw;

        let is_in_shared_memory_1st_half = |data: *const u8, size: u32| {
            let start_data = data;
            let end_data = unsafe { start_data.add(size as usize) };
            let start_shared_memory = shared_memory.as_ptr();
            let end_shared_memory_1st_half =
                unsafe { start_shared_memory.add(shared_memory.len() / 2) };
            start_shared_memory <= start_data && end_data <= end_shared_memory_1st_half
        };
        let request = request_response_pair
            .request
            .verify(&is_in_shared_memory_1st_half);
        match request {
            Ok(_) => {
                panic!("Expected request raw reconstruction to fail")
            }
            Err(e) => match e {
                ValidationError::InvalidPointer => {}
                _ => {
                    panic!("Unexpected validation error variant")
                }
            },
        }
    }

    #[test]
    fn test_invalid_enum_tag() {
        let client_id = ClientId(5);
        let request_id = RequestId(7);
        const OUTPUT_SIZE: usize = 16;
        let mut shared_memory = [0u8; mem::size_of::<RequestRaw>() + OUTPUT_SIZE];
        let request_response_start = shared_memory.as_mut_ptr();
        let output_start = unsafe { shared_memory.as_mut_ptr().add(mem::size_of::<RequestRaw>()) };
        let request = GetRandom {
            client_id,
            request_id,
            output: unsafe { slice::from_raw_parts_mut(output_start, OUTPUT_SIZE) },
        };
        let request_raw = request.into();

        // Invalidate enum tag of raw request
        unsafe {
            ptr::copy(&request_raw, request_response_start as *mut RequestRaw, 1);
            let tag: *mut u8 = request_response_start.add(offset_of!(RequestRaw, data));
            const INVALID_TAG: u8 = 0xFF;
            *tag = INVALID_TAG;
        }

        match unsafe { RequestResponseRawPair::from_raw(request_response_start) } {
            Ok(_) => {
                panic!("Expected request raw reconstruction to fail")
            }
            Err(e) => match e {
                ValidationError::InvalidTagValue => {}
                _ => {
                    panic!("Unexpected validation error variant")
                }
            },
        }
    }
}
